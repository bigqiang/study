# MySQL 学习笔记(《高性能MySQL（第3版）》)

## 逻辑架构
客户端-> 连接器 -> 解析器 -> 优化器 -> 执行器 -> 存储引擎
            |         |
            V         |
         查询缓存 <---|
连接器：管理连接，权限验证
查询缓存：命中则直接返回结果
分析器：词法分析，语法分析
优化器：执行计划生成，索引选择
执行器：操作引擎，返回结果
存储引擎：存储数据，提供读写接口

mysql -h$ip -P$port -u$user -p

InnoDB来讲，不讲MyISAM

查询缓存

n+1查询问题

报错是在哪个阶段报出？
无权限
缺少逗号，语法错误
不存在某个字段列

f1有索引，性能是否相同？
select * from T order by f1 ASC;
select * from T order by f1 DESC;

思路：先讲起作用的索引，再讲不起作用的索引

=======
 B-tree索引能加快数据的查询速度
 B-tree索引更适合进行范围查找
 
 什么情况下可以用到B树索引?
     全值匹配的查询 order_sn = "987654321"
     匹配最左前缀的查询
     匹配列前缀的查询: order_sn like "9876%"
     匹配范围值的查询:order_sn > '987654321000'  and order_sn > '987654321000'
     精确匹配左前列并范围匹配另外一列
     只访问索引的查询
=======

----------
## 索引类型
在引擎层实现，不是在服务器层实现。

### B-Tree 索引
若无特别说明多指本索引（实际很多存储引擎使用的是B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历）。InnoDB则使用的是B+Tree。
B-Tree适用于全键值、键值范围或键前缀(只适用于左前缀)查找


CREATE TABLE people (
	last_name varchar(50) not null,
	first_name varchar(50) not null,
	dob date note null,
	gender enum('m', 'f') not null,
	key (last_name, first_name, dob)
);
索引排序依据是定义索引时所列的顺序。
则前述索引对以下查询有效：
1 全值匹配：即和索引中所有列进行全值匹配
2 匹配最左前缀：查找所有 last_name='Allen'的人，即只使用索引第一列
3 匹配列前缀：查找 last_name 中所有以 J 开头的人，即也只使用索引第一列
4 匹配范围值：查找 last_name 中在 Allen 和 Barrymore 之间的人。这里也只使用索引的第一列
5 精确匹配某一列并范围匹配另外一列：
   查找所有last_name为 Allen， first_name 以 K 开头的人。即第一列全匹配，第二列范围匹配
6 只访问索引的查询：
    即查询只需要访问索引，而无须访问数据行。索引节点是有序的，除按值查找，还可以 ORDER By 操作（按顺序查找）
	如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

B-Tree索引的限制：
  如果不是按索引最左列查找，则无法使用索引。例如无法用索引查找 first_name='Bill' 的人，也无法查找某个特定生日的人，因为这两列都不是最左列数据列。
  不能路过索引中的列。例如，无法查找 last_name='Smith' 且在某个日期出生的人。如果不指定 first_name，则只能使用索引的第一列。
  如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如 WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob = '1976-12-23',这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件。如果范围查询列值有限，那么可以通过使用多个等于条件来代替范围条件。
  
这些限制并非 B-Tree 本身导致，而是 MySQL 优化器和存储引擎使用索引的方式导致，因此当前是限制未来版本可能不再是限制。

### 哈希索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
在MySQL中，只有Memory引擎支持哈希索引。Memory引擎默认支持哈希索引，同时也支持 B-Tree 索引。


## 索引的优点
减少了服务器需要扫描的数据量
可帮助服务器避免排序和临时表
索引可以将随机 I/O 变为顺序 I/O

索引是最好的解决方案吗？
对于非常小的表，大部分情况下简单的全表扫描更高效。
对于中大型的表，索引非常有效。
对于特大型的表，建立和使用索引的代价将随之增长。此时需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如可使用分区表技术（第7 章）
如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。比如执行那些需要聚合多个应用分布在多个表的数据的查询，需要记录“哪个用户的信息存储在哪个表中”的元数据。
对于TB级别数据，定位音箱记录的意义不大，所以经常会使用块级别无数据技术来代替索引。

## 高性能的索引策略

### 独立的列
如果查询的列不是独立的，则 MySQL 就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。如：
```
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 前缀索引和索引的选择性
要索引列的字符很长，会让索引变得大且慢。一个策略是前面提过的模拟哈希索引。还可以对开始部分的字符做索引，可大节约索引空间，提高索引效率。但会降低选择性。

索引的选择性：指不重复的索引值（基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。
索引的选择性越高则查询效率越高，因选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。
对于BLOB、TEXT、很长的VARCHAR类型列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。
诀窍在于，选择足够长的前缀保证较高的选择性值，同时又不能太长（节约空间）。前缀足够长，使得前缀索引的选择性接近于索引整个列。换言之，前缀的基数应该接近于完整列的基数。

前缀索引缺点：无法用于 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。


### 多列索引
一个常见错误：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

先看第一个问题，为每个列创建独立索引，SHOW CREATE TABLE 查看一个示例表t:
```SQL
CREATE TABLE t (
	c1 INT,
	c2 INT,
	c3 INT,
	KEY(c1),
	KEY(c2),
	KEY(c3)
);
```
该索引策略是由一些专家的模糊建议“把WHERE条件里面的列都建上索引”导致。该建议非常错误。这样最好的情况只能是“一星”索引，与真正最优索引差几个数量级。有时如果无法设计一个“三星”索引，那么不如忽略WHERE子句，集中精力优化索引列顺序，或创建一个全覆盖索引。

在多列上建立独立单列索引多数情况下并不提高MySQL查询性能。MySQL5.0及以上版本引入了“索引合并”(index merge)的策略，一定程序上可以使用表上的多个单列索引来定位指定的行。而早先的版本只能使用其中某一个单列索引，此时没有一个独立的单列索引是非常有效的。如：表 film_actor 在字段 film_id 和 actor_id 上各有一个单列索引。但对于查询 WHERE 条件，这两个单列索引都不是好的选择：
```
mysql> SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id=1 OR film_id=1;
```
在MySQL老版本中，MySQL对这个查询会使用全表扫描。要改成如下方式：
```
mysql> SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id=1
   -> UNION ALL
   -> SELECT film_id, actor_id FROM sakila.film_actor WHERE film_id=1
   ->     AND actor_id <> 1;
```

在 MySQL 5.0 和更新的版本中，查询能同时使用这两个单列索引进行扫描，并将结果合并。这种算法有三个变种：OR 条件的联合（union）,AND 条件的相交（intersection），组合这两种情况的联合及相交。下面的查询就是使用了两个索引扫描的联合通过 EXPLAIN 中的Extra列可以看到这点：
```
mysql> EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor
  -> WHERE actor_id = 1 OR film_id = 1\G
*************************1.row*****************************
            id: 1
   select type: SIMPLE
         table: film_actor
          type: index_merge
 possible keys: PRIMARY, idx_fk_film_id
           key: PRIMARY, idx_fk_film
           ref: NULL
          rows: 29
         Extra: Using union(PRIMARY, idx_fk_film_id); Using where
```
MySQL会使用这类技术优化复杂查询，所以在某些语句的 Extra列中还可以看到嵌套操作。

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很差：
- 当出现服务器对多个索引做相交操作时（通常有多个 AND 条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务器需要对多个索引做联合操作时(通常有多个0R条件),通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候
- 更重要的是，优化器不会把这些计算到“查询成本”(cost)中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源,还可能会影响查询的并发性,但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说,还不如像在 MySQL 4.1 或者更早的时代一样,将查询改写成 UNION的方式往往更好。

如果在 EXPLAIN 中看到有索引合并，应检查一下查询和表结构，看是否最优。也可以通过参数 optimizer_switch 来关闭索引合并功能。也可以使用 IGNORE INDEX 提示让优化器忽略掉某些索引。

### 选择合适的索引列顺序

































