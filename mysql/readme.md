# MySQL 学习笔记(《高性能MySQL（第3版）》)

## 逻辑架构
客户端-> 连接器 -> 解析器 -> 优化器 -> 执行器 -> 存储引擎
            |         |
            V         |
         查询缓存 <---|
连接器：管理连接，权限验证
查询缓存：命中则直接返回结果
分析器：词法分析，语法分析
优化器：执行计划生成，索引选择
执行器：操作引擎，返回结果
存储引擎：存储数据，提供读写接口

mysql -h$ip -P$port -u$user -p

InnoDB来讲，不讲MyISAM

查询缓存

n+1查询问题

报错是在哪个阶段报出？
无权限
缺少逗号，语法错误
不存在某个字段列

f1有索引，性能是否相同？
select * from T order by f1 ASC;
select * from T order by f1 DESC;

思路：先讲起作用的索引，再讲不起作用的索引


----------
## 索引类型
在引擎层实现，不是在服务器层实现。

### B-Tree 索引
若无特别说明多指本索引（实际很多存储引擎使用的是B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历）。InnoDB则使用的是B+Tree。
B-Tree适用于全键值、键值范围或键前缀(只适用于左前缀)查找


CREATE TABLE people (
	last_name varchar(50) not null,
	first_name varchar(50) not null,
	dob date note null,
	gender enum('m', 'f') not null,
	key (last_name, first_name, dob)
);
索引排序依据是定义索引时所列的顺序。
则前述索引对以下查询有效：
1 全值匹配：即和索引中所有列进行全值匹配
2 匹配最左前缀：查找所有 last_name='Allen'的人，即只使用索引第一列
3 匹配列前缀：查找 last_name 中所有以 J 开头的人，即也只使用索引第一列
4 匹配范围值：查找 last_name 中在 Allen 和 Barrymore 之间的人。这里也只使用索引的第一列
5 精确匹配某一列并范围匹配另外一列：
   查找所有last_name为 Allen， first_name 以 K 开头的人。即第一列全匹配，第二列范围匹配
6 只访问索引的查询：
    即查询只需要访问索引，而无须访问数据行。索引节点是有序的，除按值查找，还可以 ORDER By 操作（按顺序查找）
	如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

B-Tree索引的限制：
  如果不是按索引最左列查找，则无法使用索引。例如无法用索引查找 first_name='Bill' 的人，也无法查找某个特定生日的人，因为这两列都不是最左列数据列。
  不能路过索引中的列。例如，无法查找 last_name='Smith' 且在某个日期出生的人。如果不指定 first_name，则只能使用索引的第一列。
  如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如 WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob = '1976-12-23',这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件。如果范围查询列值有限，那么可以通过使用多个等于条件来代替范围条件。
  
这些限制并非 B-Tree 本身导致，而是 MySQL 优化器和存储引擎使用索引的方式导致，因此当前是限制未来版本可能不再是限制。

### 哈希索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
在MySQL中，只有Memory引擎支持哈希索引。Memory引擎默认支持哈希索引，同时也支持 B-Tree 索引。


## 索引的优点
减少了服务器需要扫描的数据量
可帮助服务器避免排序和临时表
索引可以将随机 I/O 变为顺序 I/O

索引是最好的解决方案吗？
对于非常小的表，大部分情况下简单的全表扫描更高效。
对于中大型的表，索引非常有效。
对于特大型的表，建立和使用索引的代价将随之增长。此时需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如可使用分区表技术（第7 章）
如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。比如执行那些需要聚合多个应用分布在多个表的数据的查询，需要记录“哪个用户的信息存储在哪个表中”的元数据。
对于TB级别数据，定位音箱记录的意义不大，所以经常会使用块级别无数据技术来代替索引。

## 高性能的索引策略

### 独立的列
如果查询的列不是独立的，则 MySQL 就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。如：
```
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 前缀索引和索引的选择性
要索引列的字符很长，会让索引变得大且慢。一个策略是前面提过的模拟哈希索引。还可以对开始部分的字符做索引，可大节约索引空间，提高索引效率。但会降低选择性。

索引的选择性：指不重复的索引值（基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。
索引的选择性越高则查询效率越高，因选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。
对于BLOB、TEXT、很长的VARCHAR类型列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。
诀窍在于，选择足够长的前缀保证较高的选择性值，同时又不能太长（节约空间）。前缀足够长，使得前缀索引的选择性接近于索引整个列。换言之，前缀的基数应该接近于完整列的基数。







































